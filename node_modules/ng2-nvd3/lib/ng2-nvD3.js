System.register(['angular2/core'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (this && this.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var core_1;
    var nvD3;
    return {
        setters:[
            function (core_1_1) {
                core_1 = core_1_1;
            }],
        execute: function() {
            nvD3 = (function () {
                function nvD3(elementRef) {
                    this.el = elementRef.nativeElement;
                }
                nvD3.prototype.ngOnChanges = function () {
                    this.updateWithOptions(this.options);
                };
                nvD3.prototype.updateWithOptions = function (options) {
                    var self = this;
                    // Clearing
                    this.clearElement();
                    // Exit if options are not yet bound
                    if (!options)
                        return;
                    // Initialize chart with specific type
                    this.chart = nv.models[options.chart.type]();
                    // Generate random chart ID
                    this.chart.id = Math.random().toString(36).substr(2, 15);
                    for (var key in this.chart) {
                        if (!this.chart.hasOwnProperty(key))
                            continue;
                        var value = this.chart[key];
                        if (key[0] === '_')
                            return;
                        else if ([
                            'clearHighlights',
                            'highlightPoint',
                            'id',
                            'options',
                            'resizeHandler',
                            'state',
                            'open',
                            'close',
                            'tooltipContent'
                        ].indexOf(key) >= 0)
                            return;
                        else if (key === 'dispatch')
                            this.configureEvents(this.chart[key], options.chart[key]);
                        else if ([
                            'bars',
                            'bars1',
                            'bars2',
                            'boxplot',
                            'bullet',
                            'controls',
                            'discretebar',
                            'distX',
                            'distY',
                            'interactiveLayer',
                            'legend',
                            'lines',
                            'lines1',
                            'lines2',
                            'multibar',
                            'pie',
                            'scatter',
                            'scatters1',
                            'scatters2',
                            'sparkline',
                            'stack1',
                            'stack2',
                            'sunburst',
                            'tooltip',
                            'x2Axis',
                            'xAxis',
                            'y1Axis',
                            'y2Axis',
                            'y3Axis',
                            'y4Axis',
                            'yAxis',
                            'yAxis1',
                            'yAxis2'
                        ].indexOf(key) >= 0 ||
                            // stacked is a component for stackedAreaChart, but a boolean for multiBarChart and multiBarHorizontalChart
                            (key === 'stacked' && options.chart.type === 'stackedAreaChart')) {
                            this.configure(this.chart[key], options.chart[key], options.chart.type);
                        }
                        else if ((key === 'xTickFormat' || key === 'yTickFormat') && options.chart.type === 'lineWithFocusChart')
                            continue;
                        else if ((key === 'tooltips') && options.chart.type === 'boxPlotChart')
                            continue;
                        else if ((key === 'tooltipXContent' || key === 'tooltipYContent') && options.chart.type === 'scatterChart')
                            continue;
                        else if (options.chart[key] === undefined || options.chart[key] === null)
                            continue;
                        else
                            this.chart[key](options.chart[key]);
                    }
                    this.updateWithData(this.data);
                    nv.addGraph(function () {
                        if (!self.chart)
                            return;
                        // Remove resize handler. Due to async execution should be placed here, not in the clearElement
                        if (self.chart.resizeHandler)
                            self.chart.resizeHandler.clear();
                        // Update the chart when window resizes
                        self.chart.resizeHandler = nv.utils.windowResize(function () {
                            self.chart && self.chart.update && self.chart.update();
                        });
                        return self.chart;
                    }, options.chart['callback']);
                };
                nvD3.prototype.updateWithData = function (data) {
                    if (data) {
                        // remove whole svg element with old data
                        d3.select(this.el).select('svg').remove();
                        var h, w;
                        // Select the current element to add <svg> element and to render the chart in
                        this.svg = d3.select(this.el).append('svg');
                        if (h = this.options.chart.height) {
                            if (!isNaN(+h))
                                h += 'px';
                            this.svg.attr('height', h).style({ height: h });
                        }
                        if (w = this.options.chart.width) {
                            if (!isNaN(+w))
                                w += 'px';
                            this.svg.attr('width', w).style({ width: w });
                        }
                        else {
                            this.svg.attr('width', '100%').style({ width: '100%' });
                        }
                        this.svg.datum(data).call(this.chart);
                    }
                };
                nvD3.prototype.configure = function (chart, options, chartType) {
                    if (chart && options) {
                        for (var key in chart) {
                            if (!chart.hasOwnProperty(key))
                                continue;
                            var value = chart[key];
                            if (key[0] === '_')
                                return;
                            else if (key === 'dispatch')
                                this.configureEvents(value, options[key]);
                            else if (key === 'tooltip')
                                this.configure(chart[key], options[key], chartType);
                            else if (key === 'contentGenerator') {
                                if (options[key])
                                    chart[key](options[key]);
                            }
                            else if ([
                                'axis',
                                'clearHighlights',
                                'defined',
                                'highlightPoint',
                                'nvPointerEventsClass',
                                'options',
                                'rangeBand',
                                'rangeBands',
                                'scatter',
                                'open',
                                'close'
                            ].indexOf(key) === -1) {
                                if (options[key] === undefined || options[key] === null)
                                    return;
                                else
                                    chart[key](options[key]);
                            }
                        }
                    }
                };
                nvD3.prototype.configureEvents = function (dispatch, options) {
                    if (dispatch && options) {
                        for (var key in dispatch) {
                            if (!dispatch.hasOwnProperty(key))
                                continue;
                            var value = dispatch[key];
                            if (options[key] === undefined || options[key] === null)
                                return;
                            else
                                dispatch.on(key + '._', options[key]);
                        }
                    }
                };
                nvD3.prototype.clearElement = function () {
                    this.el.innerHTML = '';
                    // remove tooltip if exists
                    if (this.chart && this.chart.tooltip && this.chart.tooltip.id) {
                        d3.select('#' + this.chart.tooltip.id()).remove();
                    }
                    // To be compatible with old nvd3 (v1.7.1)
                    if (nv.graphs && this.chart) {
                        for (var i = nv.graphs.length - 1; i >= 0; i--) {
                            if (nv.graphs[i] && (nv.graphs[i].id === this.chart.id)) {
                                nv.graphs.splice(i, 1);
                            }
                        }
                    }
                    if (nv.tooltip && nv.tooltip.cleanup) {
                        nv.tooltip.cleanup();
                    }
                    if (this.chart && this.chart.resizeHandler)
                        this.chart.resizeHandler.clear();
                    this.chart = null;
                };
                nvD3 = __decorate([
                    core_1.Component({
                        selector: 'nvd3',
                        inputs: ['options', 'data'],
                        template: ""
                    }),
                    __param(0, core_1.Inject(core_1.ElementRef)), 
                    __metadata('design:paramtypes', [core_1.ElementRef])
                ], nvD3);
                return nvD3;
            }());
            exports_1("nvD3", nvD3);
        }
    }
});
//# sourceMappingURL=ng2-nvd3.js.map